# 해당 문제는 3xN 크기의 벽을 2x1, 1x2 크기의 타일로 채우는 경우의 수를 구하는 문제이다.
# 문제의 풀이를 완전 탐색으로 접근해보면, 타일을 놓는 모든 경우를 직접 찾을 수 있다.
# 하지만 N이 커질수록 정답이 기하급수적으로 커지는 것이 쉽게 예상되므로, 완전 탐색 접근으로는 시간 초과가 날 것이다.
# 세야 하는 경우가 많지만, 일일이 셀 수가 없습니다. 따라서 효율적인 계산을 하기 위해서 관찰을 해보니
# 문제의 optimal subsolution을 정의하기 쉽고, 이용할 수 있을 것 같기에 DP 접근을 시도해보았다.
# 그렇다면 중복되는 연산을 줄여서 시간 복잡도를 줄일 수 있는 DP를 사용하는 것이 좋을 듯하다. 경우의 수를 구할 때 굉장히 많은 중복 연산이
# 발생할 것이라 생각하기 때문에 DP를 이용하려 한다.
# DP에는 memorization을 이용한 탑다운 방식과 tabulation을 이용한 바텀업 방식이 있다. 더 익숙한 tabulation을 이용한 바텀업 방식을 사용하겠다.
# 바텀업 방식은 작은 부분문제에서 큰 문제로 커져가면서 이전 연산을 다음 연산에서 활용하는 방식이다.
# 이를 이용하기 위해선 작은 부분문제 설정이 중요하다.
# N이 0인 경우를 생각해보자. 경우의 수는 0이 될 것이다.
# 그렇다면 N이 1인 경우를 생각해보자. 3x1인 벽이 될 것이고 경우의 수는 0가지가 나올 것이다. 그 이유는 꽉 채우지 못하기 때문이다.
# 그렇다면 N이 2인 경우를 생각해보면 3x2인 벽이 될 것이고 경우의 수는 3가지 이다.
# N이 4인 경우를 보면 2에서 내가 만들 수 있는 경우에서 만들 수 있는 경우 3가지에서 3x2 타일로 만들수 있는 경우를 곱해 9가지와 타일이 하나도 차있지 않을 때 만들 수 있는 2가지 경우가 있다.
# N이 6인 경우를 보면 4에서 만들 수 있는 경우 곱하기 3가지 더하기 2에서 만들 수 있는 경우가 2가지고 0에서 만들 수 있는 경우가 2가지 이다.

if __name__ == "__main__":
    N = int(input())
    dp = [0]*(N+1) # 테이블 초기화
    dp[0] = 1
    for i in range(2, N+1):
        dp[i] = dp[i-2]*3
        if i-4 >= 0 and i % 2 == 0:
            for j in range(i-4, -1, -2):
                dp[i] += dp[j]*2
    print(dp[N])
