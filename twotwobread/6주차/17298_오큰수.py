# 오큰수 = 오른쪽에 있으면서 Ai보다 큰 수 중 가장 왼쪽에 있는 수 , 불가 = -1
# ex) A = [3, 5, 2, 7] NGE(i) -> 1 = 5, 2 = 7, 3 = 7, 4 = -1
# A = [9, 5, 4, 8] NGE(i) -> 1 = -1, 2 = 8, 3 = 8, 4 = -1

# 문제에서 원하는 것은 i번째 원소의 오른쪽에 있는 수 중 원소값보다
# 더 큰 값 중 가장 왼쪽에 있는 수를 각 원소마다 출력하는 것이다.
# 이 경우 완전 탐색으로 접근하는 방법을 생각할 수 있지만 원소의 개수가 1백만개일 수 있기에
# 최악의 경우 O(1,000,000 ^ 2)의 시간 복잡도를 가져온다.
# 그렇다면 이진탐색을 이용할 수 있을까? 정렬을 하면 값의 순서가 바뀌기 때문에 이는 불가능하다.
# 효율적인 계산을 위해 관찰해본 결과 DP 이용도 힘들 것 같다. 그 이유는 최적의 subsolution이
# 보이지 않기 때문이다. 중복되는 연산이 없다.
# 그렇다면 브루트 포스 방식으로 최대한 시간을 덜 쓸 수 있는 방법을 생각해보자.
# 일단 구현을 위해서 동작에서의 어떤 경우들이 있는지를 생각해보자.
    # 1. [7,5,4,3, 9] 이런식으로 내림차순으로 쭉 내려가다가 이전 모든 수보다 더 큰 값이 나오는 경우
    # 2. [7,5,4,3, 4] 이런식으로 마지막 하나의 값보다 큰 값만 나오는 경우
    # 3. [7,5,4,3, 6] 이런식으로 일부의 값보다 더 큰 값만 나오는 경우
# 이렇게 3가지 경우로 생각할 수 있다.
# 이 경우를 해결할 수 있는 방법을 생각해보자.
    # 1. [7,5,4,3] 의 값에 모두 9를 넣으면된다.
    # 2. [7,5,4,3] 중 3만 4를 담고 나머지는 더 찾아봐야한다.
    # 3. [7,5,4,3] 중 5,4,3,은 6을 담고 7은 더 찾아야한다.
# 결국 생각해보면 제일 마지막에 들어온 값부터 비교하면서 그 값보다 더 작으면 그냥 탐색을 더 하고 아니면 그 값을 빼고 그 값을 뺐을때 제일 마지막에
# 들어온 값이랑 비교를 하면서 진행하는데 이런 이 기능은 스택을 이용하여 구현하는게 적절하다.
# 스택을 이용해서 이를 구현해보자.

def search_rightBiggerNumber():
    result = [-1]*N
    # 오큰수가 없다면 -1을 넣어야하기에 -1로 초기화하고 스택을 이용해서 append를 이용해서 값을 넣으면 순서에 맞지 않게 들어가기에 미리 크기를 할당하고 이를 이용
    stack = [0]
    # result 인덱스에 값을 넣어야하기에 index를 저장.

    for i in range(1, N):
        while len(stack) > 0: # sequence[i]보다 작은거를 전부다 값을 넣기 위함
            if sequence[stack[-1]] < sequence[i]:
                result[stack.pop()] = sequence[i]
            else: break # 더 크지 않으면 break
        stack.append(i) # 해당 인덱스도 오큰수를 찾기 위해 append

    for r in result:
        print(r, end=" ")

if __name__ == "__main__":
    N = int(input())
    sequence = list(map(int, input().split()))
    search_rightBiggerNumber()